#include "NIST.h"
#include "sha256.h"
#include "sha1.h"


#define MIN(x, y) (((x) < (y)) ? (x) : (y))


void NIST::initialize (HMAC_type algorithm_name)
{
	hmac_algorithm = algorithm_name;
	init_prf_function();
}

/**
* Used to define PRF, PRF_init and prf_function for debug.
*/
void NIST::init_prf_function(void)
{
  switch(hmac_algorithm)
  {
    case HMAC_SHA1:
    	init_prf = &NIST::init_hmacSha1PRF;
		prf = &NIST::hmacSha1PRF;
		prfOutputSizeBit = 160;
    break;
    case HMAC_SHA256:
    	init_prf = &NIST::init_hmacSha256PRF;
		prf = &NIST::hmacSha256PRF;
		prfOutputSizeBit = 256;
    break;
    case HMAC_SHA384:
    	//not implemented
		Serial.println("Error! HMAC_SHA384 not implemented");
    break;
    case HMAC_SHA512:
    	//not implemented
    	Serial.println("Error! HMAC_SHA512 not implemented");
    break;
    default:
    	//no other algorithms available
    	Serial.println("Error! Choose an algorithm implemented");
  }
}


void NIST::init_hmacSha1PRF (uint8_t* key, int key_length)
{
  Sha1.initHmac(key, key_length);
}

uint8_t* NIST::hmacSha1PRF (uint8_t* data, int data_length)
{
	for (int y=0; y<data_length; y++) Sha1.write(data[y]);
	return Sha1.resultHmac();
}

void NIST::init_hmacSha256PRF (uint8_t* key, int key_length)
{
  Sha256.initHmac(key, key_length);
}

uint8_t* NIST::hmacSha256PRF(uint8_t* data, int data_length)
{
	for (int y=0; y<data_length; y++) Sha256.write(data[y]);
	return Sha256.resultHmac();
}


/**
* This funcion implements the NIST SP 800-108 specifics for KDF in Counter Mode.
* Input:
*  - keyDerivationKey: is the secret key used to derive the new key = KI
*  - outputSizeBit: is an int that represents the number of bits for the new generated key = L
*  - fixedInput: is used as fixed part of "data/message" for the hmac-shaX 
*                function (NB: the dynamic part is given by the counter). In our implementation,
*                it is composed by: a || 0x00 || userID || init_time || exp_time || [outputSizeBits]2 (=>binary representation of outputSizeBits)
*  - keyDerivationKey_lenght: keyDerivationKey's number bytes
*  - fixedInput_lenght: fixedInput's number bytes
* Output:
*  - derived key: is the key material generated by KDF in Counter Mode.
*/
uint8_t* NIST::KDFCounterMode(uint8_t* keyDerivationKey, int outputSizeBit, uint8_t* fixedInput, int keyDerivationKey_lenght, int fixedInput_lenght)
{
	uint8_t ctr;
	int numCurrentElements;
	uint8_t* KI;
	uint8_t* keyDerivated;
	uint8_t* dataInput;
	int len;

	numCurrentElements = 0;
	ctr = 1;
	keyDerivated = new uint8_t[outputSizeBit];

	do{
		if(DEBUG)
			Serial.print("Iteration number "); Serial.println(ctr);

		//update data using "ctr"
		dataInput = updateDataInput(ctr, fixedInput, fixedInput_lenght);

		//init PRF function
		(this->*init_prf)(keyDerivationKey, keyDerivationKey_lenght);
		
		//use the PRF to generate KI (part of keyDerivated)
		KI = (this->*prf)(dataInput, (fixedInput_lenght+1));

		if(DEBUG)
			printBytesResulted(KI, prfOutputSizeBit);

		//decide how many bytes (so the "length") copy for currently keyDerivated?
		if (prfOutputSizeBit >= outputSizeBit) {
			len = outputSizeBit;
		} else {
			len = MIN(prfOutputSizeBit, outputSizeBit - numCurrentElements);
		}

		//copy KI in part of keyDerivated
		memcpy((keyDerivated + numCurrentElements), KI, len * sizeof(uint8_t));

		//increment ctr and numCurrentElements copied in keyDerivated
		numCurrentElements = numCurrentElements + len;
		ctr++;

	} while (numCurrentElements < outputSizeBit);

	return keyDerivated;
}


uint8_t* NIST::updateDataInput (uint8_t ctr, uint8_t* fixedInput, int fixedInput_lenght)
{
	uint8_t* tmpFixedInput = new uint8_t[fixedInput_lenght + 1]; //+1 is caused from the ctr
	tmpFixedInput[0] = ctr;
	memcpy(tmpFixedInput + 1, fixedInput, fixedInput_lenght * sizeof(uint8_t));
	return tmpFixedInput;
}



/**
* DEBUG function to print byte arrays.
*/
void NIST::printBytesResulted(uint8_t* hash, int lenght)
{
  int i;
  int limit = lenght/8;

  for (i=0; i<limit; i++)
  {
    Serial.print("0123456789abcdef"[hash[i]>>4]);
    Serial.print("0123456789abcdef"[hash[i]&0xf]);
  }
  Serial.println();
}